#!/usr/bin/env tsx

import fs from 'fs'
import path from 'path'

// Path to messages directory
const messagesDir = path.join(process.cwd(), 'messages')
const outputPath = path.join(process.cwd(), 'src/i18n/generated-types.ts')

// Read the base message file (English)
const baseMessageFile = path.join(messagesDir, 'en.json')
const messages = JSON.parse(fs.readFileSync(baseMessageFile, 'utf8'))

// Generate TypeScript interface from JSON structure
function generateInterface(obj: any, interfaceName: string, indent = 0): string {
  const spaces = '  '.repeat(indent)
  let result = `${spaces}${interfaceName}: {\n`

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'object' && value !== null) {
      result += generateInterface(value, key, indent + 1)
    } else {
      result += `${spaces}  ${key}: string\n`
    }
  }

  result += `${spaces}}\n`
  return result
}

// Generate flat key mapping for dot notation
function generateFlatKeys(obj: any, prefix = '', result: string[] = []): string[] {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key

    if (typeof value === 'object' && value !== null) {
      generateFlatKeys(value, fullKey, result)
    } else {
      result.push(`  '${fullKey}': string`)
    }
  }

  return result
}

// Generate namespace keys
function generateNamespaceKeys(obj: any): string[] {
  return Object.keys(obj).map(key => `'${key}'`)
}

// Generate the type file
const namespaceKeys = generateNamespaceKeys(messages)
const flatKeys = generateFlatKeys(messages)

const typeContent = `// Auto-generated types for i18n messages
// This file is generated by scripts/generate-i18n-types.ts
// Do not edit manually - run 'npm run generate:i18n-types' to regenerate

import type { Locale } from './config'

// Base message structure type
export interface Messages {
${Object.entries(messages).map(([key, value]) =>
    generateInterface(value, key, 1),
  ).join('')}}

// Flat key mapping for dot notation access
export interface MessageKeys {
${flatKeys.join('\n')}
}

// Namespace keys
export type NamespaceKeys = ${namespaceKeys.join(' | ')}

// All possible translation keys
export type TranslationKey = keyof MessageKeys

// Helper type for nested keys within a namespace
export type NestedKeys<T extends NamespaceKeys> = T extends keyof Messages
  ? keyof Messages[T] extends string
    ? keyof Messages[T]
    : never
  : never

// Type for translation function with namespace
export type TranslationFunction<T extends NamespaceKeys> = (
  key: NestedKeys<T>,
  values?: Record<string, any>
) => string

// Type for global translation function
export type GlobalTranslationFunction = (
  key: TranslationKey,
  values?: Record<string, any>
) => string

// Export locale type for convenience
export type { Locale }

// Message validation type
export type ValidateMessages<T> = T extends Messages ? T : never

// Type-safe key builder
export function buildTranslationKey<T extends NamespaceKeys>(
  namespace: T,
  key: NestedKeys<T>
): string {
  return \`\${namespace}.\${String(key)}\`
}
`

// Write the generated types to file
fs.writeFileSync(outputPath, typeContent)

console.log(`‚úÖ Generated i18n types at ${outputPath}`)
console.log(`üìä Generated ${flatKeys.length} translation keys`)
console.log(`üìÅ Generated ${namespaceKeys.length} namespaces: ${namespaceKeys.join(', ')}`)
